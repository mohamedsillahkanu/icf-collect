/**
 * ICF COLLECT - COMPLETE GOOGLE APPS SCRIPT
 * Handles: Form Submission, Data Retrieval, User Auth, DHIS2 Proxy, Form Cloud Storage
 * 
 * SETUP:
 * 1. Set your SPREADSHEET_ID below (or leave empty to use bound spreadsheet)
 * 2. Set your FORM_STORAGE_SHEET_ID for syncing forms across devices
 * 3. Deploy as Web App with "Anyone" access
 */

const SPREADSHEET_ID = '1tmvx7x3Z4ZYNxeaCLHsxtZrpECLqNRE6rCxk3QiFCZ8'; // Your Google Sheets ID here

// Form definitions storage sheet (for syncing forms across devices)
const FORM_STORAGE_SHEET_ID = '1WU3ZH4bGJSliemDbOTP9nolDaqNd4qvgmxCllw-SPFk';

// ============================================================
// MAIN ENTRY POINTS
// ============================================================

function doGet(e) {
  try {
    const params = e && e.parameter ? e.parameter : {};
    
    // DHIS2 Proxy GET
    if (params.url) {
      return proxyRequest(e, 'GET');
    }
    
    // Regular actions
    const action = params.action || '';
    switch(action) {
      case 'getData': return handleGetData(params);
      case 'checkUser': return handleCheckUser(params);
      case 'getCascadeData': return handleGetCascadeData(params);
      case 'ping': return jsonResponse({ success: true, message: 'ICF Collect API running' });
      default: return jsonResponse({ success: false, error: 'Unknown action' });
    }
  } catch (globalErr) {
    console.error('doGet global error:', globalErr);
    return jsonResponse({ success: false, error: 'Server error: ' + globalErr.toString() });
  }
}

function doPost(e) {
  // Global try-catch to ALWAYS return valid JSON (prevents CORS errors)
  try {
    const params = e && e.parameter ? e.parameter : {};
    
    // DHIS2 Proxy POST/PUT/DELETE
    if (params.url) {
      const method = (params.method || 'POST').toUpperCase();
      return proxyRequest(e, method);
    }
    
    // Handle form storage actions (cloud sync) - check parameter-based actions first
    const paramAction = params.action || '';
    if (['saveForm', 'loadForms', 'deleteForm'].includes(paramAction)) {
      return jsonResponse(handleFormStorage(params));
    }
    
    // Handle cascade data storage (data in POST body, params in URL)
    if (paramAction === 'saveCascadeData') {
      let cascadeData = '';
      try {
        if (e && e.postData && e.postData.contents) {
          cascadeData = e.postData.contents;
        }
      } catch(err) {
        console.error('Error reading cascade POST body:', err);
      }
      return jsonResponse(handleSaveCascadeData(params, cascadeData));
    }
    
    // Parse body for regular actions
    let data = {};
    try {
      if (e && e.postData && e.postData.contents) {
        data = JSON.parse(e.postData.contents);
      }
    } catch(err) {
      return jsonResponse({ success: false, error: 'Invalid JSON' });
    }
    
    const action = data.action || '';
    switch(action) {
      case 'submit': return handleSubmit(data);
      case 'signup': return handleSignup(data);
      case 'login': return handleLogin(data);
      case 'getData': return handleGetData(data);
      // Form storage actions (from JSON body for CORS compatibility)
      case 'saveForm': return jsonResponse(handleFormStorage(data));
      case 'loadForms': return jsonResponse(handleFormStorage(data));
      case 'deleteForm': return jsonResponse(handleFormStorage(data));
      default: return jsonResponse({ success: false, error: 'Unknown action: ' + action });
    }
  } catch (globalErr) {
    // Catch ANY error and return valid JSON to prevent CORS issues
    console.error('doPost global error:', globalErr);
    return jsonResponse({ success: false, error: 'Server error: ' + globalErr.toString() });
  }
}

// ============================================================
// FORM STORAGE (CLOUD SYNC)
// ============================================================

/**
 * Handle form storage actions
 */
function handleFormStorage(params) {
  if (!params) {
    return { success: false, error: 'No parameters provided' };
  }
  
  const action = params.action;
  const email = params.email;
  
  if (!email) {
    return { success: false, error: 'Email required' };
  }
  
  switch (action) {
    case 'saveForm':
      return saveFormDefinition(email, params.formId, params.formData);
    case 'loadForms':
      return loadFormDefinitions(email);
    case 'deleteForm':
      return deleteFormDefinition(email, params.formId, params.formTitle, params.deleteSheet === 'true');
    default:
      return { success: false, error: 'Invalid form storage action' };
  }
}

/**
 * Save a form definition to cloud storage
 */
function saveFormDefinition(email, formId, formDataJson) {
  try {
    const ss = SpreadsheetApp.openById(FORM_STORAGE_SHEET_ID);
    let sheet = ss.getSheetByName('_ICF_Forms');
    
    // Create sheet if it doesn't exist
    if (!sheet) {
      sheet = ss.insertSheet('_ICF_Forms');
      sheet.appendRow(['email', 'formId', 'formData', 'updatedAt']);
      // Format header
      sheet.getRange(1, 1, 1, 4).setBackground('#004080').setFontColor('#ffffff').setFontWeight('bold');
      sheet.setColumnWidth(1, 200);
      sheet.setColumnWidth(2, 150);
      sheet.setColumnWidth(3, 500);
      sheet.setColumnWidth(4, 180);
    }
    
    const data = sheet.getDataRange().getValues();
    let rowIndex = -1;
    
    // Find existing row for this user + form
    for (let i = 1; i < data.length; i++) {
      if (data[i][0] === email && data[i][1] === formId) {
        rowIndex = i + 1; // 1-indexed
        break;
      }
    }
    
    const now = new Date().toISOString();
    
    if (rowIndex > 0) {
      // Update existing row
      sheet.getRange(rowIndex, 3).setValue(formDataJson);
      sheet.getRange(rowIndex, 4).setValue(now);
    } else {
      // Insert new row
      sheet.appendRow([email, formId, formDataJson, now]);
    }
    
    return { success: true };
  } catch (err) {
    return { success: false, error: err.message };
  }
}

/**
 * Load all form definitions for a user from cloud storage
 */
function loadFormDefinitions(email) {
  try {
    const ss = SpreadsheetApp.openById(FORM_STORAGE_SHEET_ID);
    const sheet = ss.getSheetByName('_ICF_Forms');
    
    if (!sheet) {
      return { success: true, forms: [] };
    }
    
    const data = sheet.getDataRange().getValues();
    const forms = [];
    
    // Skip header row (i = 0)
    for (let i = 1; i < data.length; i++) {
      if (data[i][0] === email) {
        try {
          const formData = JSON.parse(data[i][2]);
          forms.push(formData);
        } catch (parseErr) {
          // Skip invalid JSON entries
          console.log('Invalid JSON for form:', data[i][1]);
        }
      }
    }
    
    return { success: true, forms: forms };
  } catch (err) {
    return { success: false, error: err.message, forms: [] };
  }
}

/**
 * Delete a form definition from cloud storage
 * Also deletes the data sheet if deleteSheet is true
 */
function deleteFormDefinition(email, formId, formTitle, deleteSheet) {
  try {
    // Delete form definition from _ICF_Forms sheet
    const formSs = SpreadsheetApp.openById(FORM_STORAGE_SHEET_ID);
    const formSheet = formSs.getSheetByName('_ICF_Forms');
    
    if (formSheet) {
      const data = formSheet.getDataRange().getValues();
      
      // Find and delete row (reverse order to handle index shifts)
      for (let i = data.length - 1; i >= 1; i--) {
        if (data[i][0] === email && data[i][1] === formId) {
          formSheet.deleteRow(i + 1); // 1-indexed
          console.log('Deleted form definition:', formId);
          break;
        }
      }
    }
    
    // Delete the data sheet if requested
    if (deleteSheet && formTitle) {
      try {
        const dataSs = SPREADSHEET_ID ? SpreadsheetApp.openById(SPREADSHEET_ID) : SpreadsheetApp.getActiveSpreadsheet();
        if (dataSs) {
          const dataSheet = dataSs.getSheetByName(formTitle);
          if (dataSheet) {
            dataSs.deleteSheet(dataSheet);
            console.log('Deleted data sheet:', formTitle);
          }
          
          // Also delete from _FormMeta if exists
          const metaSheet = dataSs.getSheetByName('_FormMeta');
          if (metaSheet && formId) {
            const metaData = metaSheet.getDataRange().getValues();
            for (let i = metaData.length - 1; i >= 1; i--) {
              if (metaData[i][0] === formId) {
                metaSheet.deleteRow(i + 1);
                console.log('Deleted form metadata:', formId);
                break;
              }
            }
          }
        }
      } catch (sheetErr) {
        console.error('Error deleting data sheet:', sheetErr);
        // Continue - form definition was deleted successfully
      }
    }
    
    return { success: true };
  } catch (err) {
    return { success: false, error: err.message };
  }
}

// ============================================================
// CASCADE DATA STORAGE (for large dropdown hierarchies)
// ============================================================

/**
 * Save cascade data to a dedicated sheet
 * Data is stored as compressed text (pipe-delimited)
 * @param {Object} params - URL parameters (cascadeId, columns)
 * @param {string} cascadeData - POST body containing the data
 */
function handleSaveCascadeData(params, cascadeData) {
  try {
    // Ensure params is an object
    params = params || {};
    
    const cascadeId = params.cascadeId;
    if (!cascadeId) {
      return { success: false, error: 'Missing cascadeId' };
    }
    
    let columns = [];
    try {
      columns = JSON.parse(params.columns || '[]');
    } catch(e) {
      columns = [];
    }
    
    const data = cascadeData || '';
    
    if (!data) {
      return { success: false, error: 'Missing cascade data in POST body' };
    }
    
    console.log('Saving cascade:', cascadeId, 'Data length:', data.length);
    
    const ss = SpreadsheetApp.openById(FORM_STORAGE_SHEET_ID);
    
    // Create or get the cascade data sheet
    let sheet = ss.getSheetByName('_ICF_CascadeData');
    if (!sheet) {
      sheet = ss.insertSheet('_ICF_CascadeData');
      sheet.getRange(1, 1, 1, 3).setValues([['cascadeId', 'columns', 'data']]);
      sheet.getRange(1, 1, 1, 3).setBackground('#004080').setFontColor('#ffffff').setFontWeight('bold');
    }
    
    // Check if cascade already exists
    const existingData = sheet.getDataRange().getValues();
    let rowIndex = -1;
    for (let i = 1; i < existingData.length; i++) {
      if (existingData[i][0] === cascadeId) {
        rowIndex = i + 1;
        break;
      }
    }
    
    const columnsJson = JSON.stringify(columns);
    
    if (rowIndex > 0) {
      // Update existing
      sheet.getRange(rowIndex, 2).setValue(columnsJson);
      sheet.getRange(rowIndex, 3).setValue(data);
    } else {
      // Insert new
      sheet.appendRow([cascadeId, columnsJson, data]);
    }
    
    console.log('Saved cascade data:', cascadeId);
    return { success: true };
  } catch (err) {
    console.error('Save cascade error:', err);
    return { success: false, error: err.message };
  }
}

/**
 * Get cascade data by ID
 * Returns compressed text data
 */
function handleGetCascadeData(params) {
  try {
    // Ensure params is an object
    params = params || {};
    
    const cascadeId = params.cascadeId;
    
    if (!cascadeId) {
      return jsonResponse({ success: false, error: 'Missing cascadeId' });
    }
    
    const ss = SpreadsheetApp.openById(FORM_STORAGE_SHEET_ID);
    const sheet = ss.getSheetByName('_ICF_CascadeData');
    
    if (!sheet) {
      return jsonResponse({ success: false, error: 'Cascade data not found' });
    }
    
    const data = sheet.getDataRange().getValues();
    
    for (let i = 1; i < data.length; i++) {
      if (data[i][0] === cascadeId) {
        const columns = JSON.parse(data[i][1] || '[]');
        const cascadeData = data[i][2] || ''; // Return as compressed text
        
        console.log('Retrieved cascade data:', cascadeId);
        return jsonResponse({ 
          success: true, 
          columns: columns,
          data: cascadeData 
        });
      }
    }
    
    return jsonResponse({ success: false, error: 'Cascade ID not found: ' + cascadeId });
  } catch (err) {
    console.error('Get cascade error:', err);
    return jsonResponse({ success: false, error: err.message });
  }
}

// ============================================================
// DHIS2 PROXY
// ============================================================

function proxyRequest(e, defaultMethod) {
  try {
    if (!e || !e.parameter) {
      return jsonResponse({ error: 'Invalid request' });
    }
    
    const url = e.parameter.url;
    if (!url) {
      return jsonResponse({ error: 'Missing url parameter' });
    }
    
    const method = (e.parameter.method || defaultMethod).toUpperCase();
    
    const options = {
      method: method.toLowerCase(),
      muteHttpExceptions: true,
      followRedirects: true,
      validateHttpsCertificates: false,
      headers: { 
        'Accept': 'application/json',
        'Content-Type': 'application/json'
      }
    };
    
    // Add auth header
    if (e.parameter.auth) {
      options.headers['Authorization'] = 'Basic ' + e.parameter.auth;
    }
    
    // Add body for POST/PUT
    if (e.postData && e.postData.contents && (method === 'POST' || method === 'PUT')) {
      options.payload = e.postData.contents;
    }
    
    console.log('Proxy:', method, url);
    
    const response = UrlFetchApp.fetch(url, options);
    const content = response.getContentText();
    const code = response.getResponseCode();
    
    console.log('Response:', code, content.substring(0, 200));
    
    return ContentService.createTextOutput(content)
      .setMimeType(ContentService.MimeType.JSON);
    
  } catch (err) {
    console.error('Proxy error:', err);
    return jsonResponse({ error: 'Proxy failed: ' + err.toString() });
  }
}

// ============================================================
// FORM SUBMISSION
// Row 1 = Labels, Row 2 = Variable Names, Row 3+ = Data
// Handles: Form rename, Field addition, Field deletion
// ============================================================

function handleSubmit(data) {
  try {
    const formTitle = data.formTitle || 'Default';
    const formId = data.formId || null; // Unique form identifier
    const oldFormTitle = data.oldFormTitle || null; // Previous title if renamed
    const fields = data.fields || []; // Array of {label, name}
    const rowData = data.data || {};
    const syncSchema = data.syncSchema !== false; // Default true - sync columns with form definition
    
    if (!rowData || Object.keys(rowData).length === 0) {
      return jsonResponse({ success: false, error: 'No data provided' });
    }
    
    // Get spreadsheet
    let ss;
    try {
      ss = SPREADSHEET_ID ? SpreadsheetApp.openById(SPREADSHEET_ID) : SpreadsheetApp.getActiveSpreadsheet();
    } catch(e) {
      ss = SpreadsheetApp.getActiveSpreadsheet();
    }
    
    if (!ss) {
      return jsonResponse({ success: false, error: 'No spreadsheet. Set SPREADSHEET_ID or bind script to a sheet.' });
    }
    
    // Handle form rename - check if old sheet exists and rename it
    let sheet = ss.getSheetByName(formTitle);
    
    if (!sheet && oldFormTitle) {
      // Try to find sheet with old name and rename it
      const oldSheet = ss.getSheetByName(oldFormTitle);
      if (oldSheet) {
        oldSheet.setName(formTitle);
        sheet = oldSheet;
        console.log('Renamed sheet from', oldFormTitle, 'to', formTitle);
      }
    }
    
    // Also check form metadata for ID-based lookup
    if (!sheet && formId) {
      sheet = findSheetByFormId(ss, formId);
      if (sheet && sheet.getName() !== formTitle) {
        // Rename to new title
        const oldName = sheet.getName();
        sheet.setName(formTitle);
        console.log('Renamed sheet from', oldName, 'to', formTitle, '(by formId)');
      }
    }
    
    let isNewSheet = false;
    
    if (!sheet) {
      sheet = ss.insertSheet(formTitle);
      isNewSheet = true;
    }
    
    // Store form metadata (formId -> sheetName mapping)
    if (formId) {
      updateFormMetadata(ss, formId, formTitle);
    }
    
    // Determine headers from fields or existing sheet
    let labels = [];
    let names = [];
    
    if (isNewSheet || sheet.getLastRow() < 2) {
      // New sheet - create headers from field definitions
      if (fields.length > 0) {
        labels = fields.map(f => f.label);
        names = fields.map(f => f.name);
      } else {
        // Fallback to data keys
        names = Object.keys(rowData);
        labels = names.map(n => n);
      }
      
      // Write Row 1 (Labels) and Row 2 (Names)
      sheet.getRange(1, 1, 1, labels.length).setValues([labels]);
      sheet.getRange(2, 1, 1, names.length).setValues([names]);
      
      // Format header rows
      sheet.getRange(1, 1, 1, labels.length).setBackground('#004080').setFontColor('#ffffff').setFontWeight('bold');
      sheet.getRange(2, 1, 1, names.length).setBackground('#e0e0e0').setFontWeight('bold').setFontStyle('italic');
      
    } else {
      // Existing sheet - sync schema if fields provided
      const lastCol = sheet.getLastColumn();
      if (lastCol > 0) {
        const existingLabels = sheet.getRange(1, 1, 1, lastCol).getValues()[0];
        const existingNames = sheet.getRange(2, 1, 1, lastCol).getValues()[0];
        
        if (syncSchema && fields.length > 0) {
          // Sync columns with current form definition
          const syncResult = syncSheetSchema(sheet, fields, existingNames, existingLabels);
          names = syncResult.names;
          labels = syncResult.labels;
        } else {
          // Just use existing + add new
          names = existingNames.slice();
          labels = existingLabels.slice();
          
          const existingNamesSet = new Set(names);
          
          if (fields.length > 0) {
            fields.forEach(f => {
              if (!existingNamesSet.has(f.name)) {
                names.push(f.name);
                labels.push(f.label);
              }
            });
          } else {
            Object.keys(rowData).forEach(name => {
              if (!existingNamesSet.has(name)) {
                names.push(name);
                labels.push(name);
              }
            });
          }
          
          // Add new columns if needed
          if (names.length > lastCol) {
            for (let i = lastCol; i < names.length; i++) {
              sheet.getRange(1, i + 1).setValue(labels[i]).setBackground('#004080').setFontColor('#ffffff').setFontWeight('bold');
              sheet.getRange(2, i + 1).setValue(names[i]).setBackground('#e0e0e0').setFontWeight('bold').setFontStyle('italic');
            }
          }
        }
      }
    }
    
    // Create row with values in correct column order
    const row = names.map(name => {
      const value = rowData[name];
      if (value === undefined || value === null) return '';
      if (typeof value === 'object') return JSON.stringify(value);
      return value;
    });
    
    // Append the row (data starts at row 3)
    sheet.appendRow(row);
    
    console.log('Saved to sheet:', formTitle, 'Row:', sheet.getLastRow());
    
    return jsonResponse({ 
      success: true, 
      message: 'Data saved',
      sheet: formTitle,
      row: sheet.getLastRow()
    });
    
  } catch(err) {
    console.error('Submit error:', err);
    return jsonResponse({ success: false, error: err.toString() });
  }
}

/**
 * Sync sheet schema with form definition
 * - Adds new columns
 * - Removes deleted columns (moves data)
 * - Reorders columns to match form order
 */
function syncSheetSchema(sheet, fields, existingNames, existingLabels) {
  const fieldNames = fields.map(f => f.name);
  const fieldLabels = fields.map(f => f.label);
  const fieldNameSet = new Set(fieldNames);
  
  // Find columns to remove (exist in sheet but not in form)
  const columnsToRemove = [];
  for (let i = 0; i < existingNames.length; i++) {
    const name = existingNames[i];
    // Keep system fields (starting with _) and fields that still exist
    if (name && !name.startsWith('_') && !fieldNameSet.has(name)) {
      columnsToRemove.push(i);
    }
  }
  
  // Remove columns in reverse order (to maintain indices)
  if (columnsToRemove.length > 0) {
    console.log('Removing columns:', columnsToRemove.map(i => existingNames[i]).join(', '));
    for (let i = columnsToRemove.length - 1; i >= 0; i--) {
      const colIndex = columnsToRemove[i] + 1; // 1-indexed
      sheet.deleteColumn(colIndex);
    }
  }
  
  // Get updated columns after deletion
  const lastCol = sheet.getLastColumn();
  let currentNames = lastCol > 0 ? sheet.getRange(2, 1, 1, lastCol).getValues()[0] : [];
  let currentLabels = lastCol > 0 ? sheet.getRange(1, 1, 1, lastCol).getValues()[0] : [];
  
  // Build final column list: keep system fields first, then form fields in order
  const systemFields = [];
  const systemLabels = [];
  for (let i = 0; i < currentNames.length; i++) {
    if (currentNames[i] && currentNames[i].toString().startsWith('_')) {
      systemFields.push(currentNames[i]);
      systemLabels.push(currentLabels[i]);
    }
  }
  
  // Final order: form fields (which may include system fields like _id, _timestamp)
  const finalNames = fieldNames.slice();
  const finalLabels = fieldLabels.slice();
  
  // Add any system fields not in form definition
  systemFields.forEach((name, i) => {
    if (!fieldNameSet.has(name)) {
      finalNames.unshift(name);
      finalLabels.unshift(systemLabels[i]);
    }
  });
  
  // Add new columns that don't exist
  const currentNameSet = new Set(currentNames);
  const colsToAdd = [];
  
  for (let i = 0; i < finalNames.length; i++) {
    if (!currentNameSet.has(finalNames[i])) {
      colsToAdd.push({ name: finalNames[i], label: finalLabels[i] });
    }
  }
  
  // Add new columns at the end
  if (colsToAdd.length > 0) {
    const startCol = sheet.getLastColumn() + 1;
    colsToAdd.forEach((col, i) => {
      sheet.getRange(1, startCol + i).setValue(col.label).setBackground('#004080').setFontColor('#ffffff').setFontWeight('bold');
      sheet.getRange(2, startCol + i).setValue(col.name).setBackground('#e0e0e0').setFontWeight('bold').setFontStyle('italic');
    });
    console.log('Added columns:', colsToAdd.map(c => c.name).join(', '));
  }
  
  // Return the final column order (read fresh from sheet)
  const newLastCol = sheet.getLastColumn();
  const newNames = newLastCol > 0 ? sheet.getRange(2, 1, 1, newLastCol).getValues()[0] : [];
  const newLabels = newLastCol > 0 ? sheet.getRange(1, 1, 1, newLastCol).getValues()[0] : [];
  
  return { names: newNames, labels: newLabels };
}

/**
 * Find sheet by form ID using metadata
 */
function findSheetByFormId(ss, formId) {
  const metaSheet = ss.getSheetByName('_FormMeta');
  if (!metaSheet || metaSheet.getLastRow() < 2) return null;
  
  const data = metaSheet.getDataRange().getValues();
  for (let i = 1; i < data.length; i++) {
    if (data[i][0] === formId) {
      const sheetName = data[i][1];
      return ss.getSheetByName(sheetName);
    }
  }
  return null;
}

/**
 * Update form metadata (formId -> sheetName mapping)
 */
function updateFormMetadata(ss, formId, sheetName) {
  let metaSheet = ss.getSheetByName('_FormMeta');
  
  if (!metaSheet) {
    metaSheet = ss.insertSheet('_FormMeta');
    metaSheet.getRange(1, 1, 1, 3).setValues([['formId', 'sheetName', 'updatedAt']]);
    metaSheet.getRange(1, 1, 1, 3).setBackground('#004080').setFontColor('#ffffff').setFontWeight('bold');
  }
  
  const data = metaSheet.getDataRange().getValues();
  let rowIndex = -1;
  
  for (let i = 1; i < data.length; i++) {
    if (data[i][0] === formId) {
      rowIndex = i + 1;
      break;
    }
  }
  
  const now = new Date().toISOString();
  
  if (rowIndex > 0) {
    metaSheet.getRange(rowIndex, 2).setValue(sheetName);
    metaSheet.getRange(rowIndex, 3).setValue(now);
  } else {
    metaSheet.appendRow([formId, sheetName, now]);
  }
}

// ============================================================
// DATA RETRIEVAL
// Row 1 = Labels, Row 2 = Variable Names, Row 3+ = Data
// ============================================================

function handleGetData(params) {
  try {
    // Ensure params is an object
    params = params || {};
    
    const formTitle = params.formTitle || 'Default';
    const limit = parseInt(params.limit) || 1000;
    
    let ss;
    try {
      ss = SPREADSHEET_ID ? SpreadsheetApp.openById(SPREADSHEET_ID) : SpreadsheetApp.getActiveSpreadsheet();
    } catch(e) {
      ss = SpreadsheetApp.getActiveSpreadsheet();
    }
    
    if (!ss) {
      return jsonResponse({ success: true, data: [], message: 'No spreadsheet' });
    }
    
    const sheet = ss.getSheetByName(formTitle);
    if (!sheet) {
      return jsonResponse({ success: true, data: [], message: 'Sheet not found: ' + formTitle });
    }
    
    const lastRow = sheet.getLastRow();
    const lastCol = sheet.getLastColumn();
    
    // Need at least 3 rows (labels, names, 1 data row)
    if (lastRow < 3 || lastCol < 1) {
      return jsonResponse({ success: true, data: [] });
    }
    
    // Get all data
    const allData = sheet.getRange(1, 1, lastRow, lastCol).getValues();
    
    // Row 1 = Labels (for display), Row 2 = Variable Names (for data keys)
    const labels = allData[0];
    const names = allData[1];
    
    // Data starts from Row 3 (index 2)
    const dataRows = allData.slice(2, Math.min(allData.length, limit + 2));
    
    // Convert to array of objects using variable names as keys
    const result = dataRows.map(row => {
      const obj = {};
      names.forEach((name, i) => {
        if (name) obj[name] = row[i];
      });
      return obj;
    });
    
    console.log('GetData:', formTitle, result.length, 'records');
    
    return jsonResponse({ 
      success: true, 
      data: result,
      count: result.length,
      labels: labels,
      names: names
    });
    
  } catch(err) {
    console.error('GetData error:', err);
    return jsonResponse({ success: false, error: err.toString(), data: [] });
  }
}

// ============================================================
// USER AUTH
// ============================================================

function handleSignup(data) {
  try {
    const name = data.name || '';
    const email = (data.email || '').toLowerCase().trim();
    const password = data.password || '';
    
    if (!email || !password) {
      return jsonResponse({ success: false, error: 'Email and password required' });
    }
    
    const ss = getSpreadsheet();
    let sheet = ss.getSheetByName('_Users');
    
    if (!sheet) {
      sheet = ss.insertSheet('_Users');
      sheet.getRange(1, 1, 1, 4).setValues([['id', 'name', 'email', 'password']]);
    }
    
    // Check if exists
    const lastRow = sheet.getLastRow();
    if (lastRow > 1) {
      const emails = sheet.getRange(2, 3, lastRow - 1, 1).getValues();
      for (let i = 0; i < emails.length; i++) {
        if (emails[i][0].toString().toLowerCase().trim() === email) {
          return jsonResponse({ success: false, error: 'Email already registered' });
        }
      }
    }
    
    const userId = 'user_' + Date.now();
    sheet.appendRow([userId, name, email, password]);
    
    return jsonResponse({ 
      success: true, 
      user: { id: userId, name: name, email: email }
    });
    
  } catch(err) {
    return jsonResponse({ success: false, error: err.toString() });
  }
}

function handleLogin(data) {
  try {
    const email = (data.email || '').toLowerCase().trim();
    const password = data.password || '';
    
    if (!email || !password) {
      return jsonResponse({ success: false, error: 'Email and password required' });
    }
    
    const ss = getSpreadsheet();
    const sheet = ss.getSheetByName('_Users');
    
    if (!sheet || sheet.getLastRow() < 2) {
      return jsonResponse({ success: false, error: 'Invalid credentials' });
    }
    
    const users = sheet.getRange(2, 1, sheet.getLastRow() - 1, 4).getValues();
    
    for (let i = 0; i < users.length; i++) {
      if (users[i][2].toString().toLowerCase().trim() === email && 
          users[i][3].toString() === password) {
        return jsonResponse({ 
          success: true, 
          user: { id: users[i][0], name: users[i][1], email: email }
        });
      }
    }
    
    return jsonResponse({ success: false, error: 'Invalid credentials' });
    
  } catch(err) {
    return jsonResponse({ success: false, error: err.toString() });
  }
}

function handleCheckUser(params) {
  try {
    if (!params) params = {};
    const email = (params.email || '').toLowerCase().trim();
    if (!email) return jsonResponse({ success: true, exists: false });
    
    const ss = getSpreadsheet();
    const sheet = ss.getSheetByName('_Users');
    if (!sheet || sheet.getLastRow() < 2) {
      return jsonResponse({ success: true, exists: false });
    }
    
    const emails = sheet.getRange(2, 3, sheet.getLastRow() - 1, 1).getValues();
    for (let i = 0; i < emails.length; i++) {
      if (emails[i][0].toString().toLowerCase().trim() === email) {
        return jsonResponse({ success: true, exists: true });
      }
    }
    
    return jsonResponse({ success: true, exists: false });
  } catch(err) {
    return jsonResponse({ success: false, exists: false });
  }
}

// ============================================================
// HELPERS
// ============================================================

function getSpreadsheet() {
  if (SPREADSHEET_ID) {
    try { return SpreadsheetApp.openById(SPREADSHEET_ID); } catch(e) {}
  }
  return SpreadsheetApp.getActiveSpreadsheet();
}

function jsonResponse(obj) {
  return ContentService.createTextOutput(JSON.stringify(obj))
    .setMimeType(ContentService.MimeType.JSON);
}

// ============================================================
// TEST FUNCTIONS
// ============================================================

function testSpreadsheet() {
  const ss = getSpreadsheet();
  if (ss) {
    Logger.log('✓ Spreadsheet found: ' + ss.getName());
    Logger.log('✓ ID: ' + ss.getId());
    Logger.log('✓ Sheets: ' + ss.getSheets().map(s => s.getName()).join(', '));
  } else {
    Logger.log('✗ No spreadsheet found. Check SPREADSHEET_ID');
  }
}

function testFormStorage() {
  try {
    const ss = SpreadsheetApp.openById(FORM_STORAGE_SHEET_ID);
    Logger.log('✓ Form Storage Sheet found: ' + ss.getName());
  } catch(err) {
    Logger.log('✗ Form Storage Sheet error: ' + err.message);
  }
}

function testSetup() {
  Logger.log('=== Testing ICF Collect Setup ===\n');
  testSpreadsheet();
  Logger.log('');
  testFormStorage();
  Logger.log('\n✓ Setup complete! Deploy as Web App to use.');
}
